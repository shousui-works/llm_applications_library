name: PR Auto Labeler

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Auto-label PR based on title and content
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const title = context.payload.pull_request.title.toLowerCase();
          const body = context.payload.pull_request.body ? context.payload.pull_request.body.toLowerCase() : '';
          const branchName = context.payload.pull_request.head.ref.toLowerCase();

          console.log('PR Title:', title);
          console.log('PR Branch:', branchName);

          // æ—¢å­˜ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
          const existingLabels = context.payload.pull_request.labels.map(label => label.name);
          console.log('Existing labels:', existingLabels);

          const labelsToAdd = [];

          // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
          if (title.includes('breaking') || title.includes('major') ||
              body.includes('breaking change') || body.includes('breaking:')) {
            if (!existingLabels.includes('major')) {
              labelsToAdd.push('major');
            }
          } else if (title.match(/^feat(?:\(.*\))?[!:]/) || title.includes('feature') ||
                     branchName.includes('feature') || branchName.includes('feat') ||
                     title.includes('æ–°æ©Ÿèƒ½') || title.includes('æ©Ÿèƒ½è¿½åŠ ')) {
            if (!existingLabels.includes('minor') && !existingLabels.includes('feature')) {
              labelsToAdd.push('minor');
              labelsToAdd.push('feature');
            }
          } else if (title.match(/^fix(?:\(.*\))?[!:]/) || title.includes('bugfix') ||
                     title.includes('hotfix') || branchName.includes('fix') ||
                     branchName.includes('bugfix') || branchName.includes('hotfix') ||
                     title.includes('ä¿®æ­£') || title.includes('ãƒã‚°')) {
            if (!existingLabels.includes('patch') && !existingLabels.includes('bugfix')) {
              labelsToAdd.push('patch');
              labelsToAdd.push('bugfix');
            }
          } else if (title.match(/^docs(?:\(.*\))?[!:]/) || title.includes('documentation') ||
                     branchName.includes('docs') || title.includes('ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ')) {
            if (!existingLabels.includes('documentation')) {
              labelsToAdd.push('documentation');
              labelsToAdd.push('patch'); // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ã¯patchæ‰±ã„
            }
          } else if (title.match(/^test(?:\(.*\))?[!:]/) || title.includes('testing') ||
                     branchName.includes('test') || title.includes('ãƒ†ã‚¹ãƒˆ')) {
            if (!existingLabels.includes('test')) {
              labelsToAdd.push('test');
              labelsToAdd.push('patch'); // ãƒ†ã‚¹ãƒˆè¿½åŠ ã¯patchæ‰±ã„
            }
          } else if (title.match(/^chore(?:\(.*\))?[!:]/) || title.includes('chore') ||
                     title.includes('refactor') || branchName.includes('chore') ||
                     title.includes('æ•´å‚™') || title.includes('ãƒªãƒ•ã‚¡ã‚¯ã‚¿')) {
            if (!existingLabels.includes('maintenance')) {
              labelsToAdd.push('maintenance');
              labelsToAdd.push('patch'); // ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã¯patchæ‰±ã„
            }
          } else {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯patch
            if (!existingLabels.some(label => ['major', 'minor', 'patch'].includes(label))) {
              labelsToAdd.push('patch');
            }
          }

          // CI/CDé–¢é€£ã®æ¤œå‡º
          if (branchName.includes('ci') || branchName.includes('workflow') ||
              title.includes('ci:') || title.includes('workflow') ||
              title.includes('github actions')) {
            if (!existingLabels.includes('ci/cd')) {
              labelsToAdd.push('ci/cd');
            }
          }

          // ä¾å­˜é–¢ä¿‚æ›´æ–°ã®æ¤œå‡º
          if (title.includes('bump') || title.includes('update') &&
              (title.includes('dependency') || title.includes('deps') ||
               title.includes('requirement') || title.includes('ä¾å­˜'))) {
            if (!existingLabels.includes('dependencies')) {
              labelsToAdd.push('dependencies');
            }
          }

          // ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
          if (labelsToAdd.length > 0) {
            console.log('Adding labels:', labelsToAdd);

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: labelsToAdd
            });

            // ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜
            const comment = `ğŸ¤– **è‡ªå‹•ãƒ©ãƒ™ãƒªãƒ³ã‚°å®Œäº†**

ã“ã®PRã«ä»¥ä¸‹ã®ãƒ©ãƒ™ãƒ«ã‚’è‡ªå‹•ã§è¿½åŠ ã—ã¾ã—ãŸï¼š
${labelsToAdd.map(label => `- \`${label}\``).join('\n')}

**ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒãƒ³ãƒ—äºˆå®š**: ${labelsToAdd.includes('major') ? 'MAJOR' : labelsToAdd.includes('minor') ? 'MINOR' : 'PATCH'}

> â— ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒãƒ³ãƒ—ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´ã—ãŸã„å ´åˆã¯ã€é©åˆ‡ãªãƒ©ãƒ™ãƒ«(\`major\`, \`minor\`, \`patch\`)ã‚’æ‰‹å‹•ã§è¿½åŠ /å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
          }

          console.log('Labeling completed!');